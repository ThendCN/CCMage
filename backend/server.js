const express = require('express');
const cors = require('cors');
const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');
const util = require('util');
const { registerProcessRoutes } = require('./routes');
const { registerManagementRoutes } = require('./managementRoutes');
const { registerAnalysisRoutes } = require('./analysisRoutes');
const processManager = require('./processManager');
const db = require('./database');
require('dotenv').config({ path: path.resolve(__dirname, '../.env') });

const execPromise = util.promisify(exec);

const app = express();
const PORT = process.env.PORT || 9999;

// é¡¹ç›®æ ¹ç›®å½•é…ç½®
// ä¼˜å…ˆä½¿ç”¨ç¯å¢ƒå˜é‡é…ç½®çš„ç»å¯¹è·¯å¾„ï¼Œé¿å…ç›¸å¯¹è·¯å¾„é—®é¢˜
// å¦‚æœæœªé…ç½®ï¼Œé»˜è®¤ä½¿ç”¨ backend çš„ä¸Šä¸€çº§ç›®å½•ï¼ˆproject-managerï¼‰
const PROJECT_ROOT = process.env.PROJECT_ROOT
  ? path.resolve(process.env.PROJECT_ROOT)
  : path.resolve(__dirname, '..');
const PROJECTS_CONFIG = path.join(PROJECT_ROOT, '.claude/projects.json');
const ENV_FILE = path.resolve(__dirname, '../.env');

app.use(cors());
app.use(express.json());

// æä¾›å‰ç«¯é™æ€æ–‡ä»¶
app.use(express.static(path.join(__dirname, '../frontend/dist')));

// ========== API è·¯ç”± ==========

// é…ç½®ç®¡ç†API
// è·å–é…ç½®
app.get('/api/config', (req, res) => {
  try {
    const config = {
      ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY || '',
      ANTHROPIC_BASE_URL: process.env.ANTHROPIC_BASE_URL || 'https://api.husanai.com',
      PROJECT_ROOT: process.env.PROJECT_ROOT || ''
    };
    res.json(config);
  } catch (error) {
    res.status(500).json({ error: 'è¯»å–é…ç½®å¤±è´¥', message: error.message });
  }
});

// ä¿å­˜é…ç½®
app.post('/api/config', (req, res) => {
  try {
    const { ANTHROPIC_API_KEY, ANTHROPIC_BASE_URL, PROJECT_ROOT } = req.body;

    // è¯»å–ç°æœ‰çš„ .env æ–‡ä»¶æˆ–åˆ›å»ºæ–°çš„
    let envContent = '';
    if (fs.existsSync(ENV_FILE)) {
      envContent = fs.readFileSync(ENV_FILE, 'utf8');
    }

    // è§£æç°æœ‰é…ç½®
    const envLines = envContent.split('\n');
    const envMap = new Map();
    const comments = [];

    envLines.forEach(line => {
      if (line.trim().startsWith('#') || line.trim() === '') {
        comments.push(line);
      } else if (line.includes('=')) {
        const [key, ...valueParts] = line.split('=');
        envMap.set(key.trim(), valueParts.join('=').trim());
      }
    });

    // æ›´æ–°é…ç½®
    if (ANTHROPIC_API_KEY !== undefined) {
      envMap.set('ANTHROPIC_API_KEY', ANTHROPIC_API_KEY);
    }
    if (ANTHROPIC_BASE_URL !== undefined) {
      envMap.set('ANTHROPIC_BASE_URL', ANTHROPIC_BASE_URL);
    }
    if (PROJECT_ROOT !== undefined) {
      envMap.set('PROJECT_ROOT', PROJECT_ROOT);
    }

    // ç”Ÿæˆæ–°çš„ .env å†…å®¹
    const newEnvContent = [
      '# Environment Configuration',
      '# Generated by Claude Code Project Manager',
      '',
      '# Claude API Configuration',
      `ANTHROPIC_API_KEY=${envMap.get('ANTHROPIC_API_KEY') || ''}`,
      `ANTHROPIC_BASE_URL=${envMap.get('ANTHROPIC_BASE_URL') || 'https://api.husanai.com'}`,
      '',
      '# Server Configuration',
      `PORT=${envMap.get('PORT') || '9999'}`,
      '',
      '# Project Root',
      `PROJECT_ROOT=${envMap.get('PROJECT_ROOT') || ''}`,
      ''
    ].join('\n');

    fs.writeFileSync(ENV_FILE, newEnvContent, 'utf8');

    // æ›´æ–°ç¯å¢ƒå˜é‡
    process.env.ANTHROPIC_API_KEY = envMap.get('ANTHROPIC_API_KEY') || '';
    process.env.ANTHROPIC_BASE_URL = envMap.get('ANTHROPIC_BASE_URL') || 'https://api.husanai.com';
    process.env.PROJECT_ROOT = envMap.get('PROJECT_ROOT') || '';

    res.json({ success: true, message: 'é…ç½®ä¿å­˜æˆåŠŸ' });
  } catch (error) {
    res.status(500).json({ error: 'ä¿å­˜é…ç½®å¤±è´¥', message: error.message });
  }
});

// 1. è·å–æ‰€æœ‰é¡¹ç›®
app.get('/api/projects', (req, res) => {
  try {
    const config = JSON.parse(fs.readFileSync(PROJECTS_CONFIG, 'utf8'));
    res.json(config);
  } catch (error) {
    res.status(500).json({ error: 'è¯»å–é¡¹ç›®é…ç½®å¤±è´¥', message: error.message });
  }
});

// 2. è·å–å•ä¸ªé¡¹ç›®çŠ¶æ€
app.get('/api/projects/:name/status', async (req, res) => {
  try {
    const { name } = req.params;
    const config = JSON.parse(fs.readFileSync(PROJECTS_CONFIG, 'utf8'));

    // æŸ¥æ‰¾é¡¹ç›®ï¼ˆå¯èƒ½åœ¨ projects æˆ– external ä¸­ï¼‰
    let project = config.projects[name];
    if (!project && config.external && config.external[name]) {
      project = config.external[name];
    }

    if (!project) {
      return res.status(404).json({ error: 'é¡¹ç›®ä¸å­˜åœ¨' });
    }

    // å¦‚æœæ˜¯ç»å¯¹è·¯å¾„ç›´æ¥ä½¿ç”¨ï¼Œå¦åˆ™ç›¸å¯¹äºé¡¹ç›®æ ¹ç›®å½•
    const projectPath = path.isAbsolute(project.path)
      ? project.path
      : path.join(PROJECT_ROOT, project.path);
    const status = await checkProjectStatus(projectPath, project);

    res.json({ name, ...status });
  } catch (error) {
    res.status(500).json({ error: 'æ£€æŸ¥é¡¹ç›®çŠ¶æ€å¤±è´¥', message: error.message });
  }
});

// 3. æ‰¹é‡è·å–é¡¹ç›®çŠ¶æ€
app.post('/api/projects/status/batch', async (req, res) => {
  try {
    const { projectNames } = req.body;
    const config = JSON.parse(fs.readFileSync(PROJECTS_CONFIG, 'utf8'));

    const statusPromises = projectNames.map(async (name) => {
      // æŸ¥æ‰¾é¡¹ç›®ï¼ˆå¯èƒ½åœ¨ projects æˆ– external ä¸­ï¼‰
      let project = config.projects[name];
      if (!project && config.external && config.external[name]) {
        project = config.external[name];
      }

      if (!project) return { name, error: 'é¡¹ç›®ä¸å­˜åœ¨' };

      // å¦‚æœæ˜¯ç»å¯¹è·¯å¾„ç›´æ¥ä½¿ç”¨ï¼Œå¦åˆ™ç›¸å¯¹äºé¡¹ç›®æ ¹ç›®å½•
      const projectPath = path.isAbsolute(project.path)
        ? project.path
        : path.join(PROJECT_ROOT, project.path);
      const status = await checkProjectStatus(projectPath, project);
      return { name, ...status };
    });

    const results = await Promise.all(statusPromises);
    res.json(results);
  } catch (error) {
    res.status(500).json({ error: 'æ‰¹é‡æ£€æŸ¥å¤±è´¥', message: error.message });
  }
});

// 4. æ›´æ–°é¡¹ç›®é…ç½®
app.put('/api/projects', (req, res) => {
  try {
    const newConfig = req.body;
    fs.writeFileSync(PROJECTS_CONFIG, JSON.stringify(newConfig, null, 2), 'utf8');
    res.json({ success: true, message: 'é…ç½®æ›´æ–°æˆåŠŸ' });
  } catch (error) {
    res.status(500).json({ error: 'æ›´æ–°é…ç½®å¤±è´¥', message: error.message });
  }
});

// 5. æ‰§è¡Œé¡¹ç›®æ“ä½œ
app.post('/api/projects/:name/action', async (req, res) => {
  try {
    const { name } = req.params;
    const { action, params } = req.body;

    const config = JSON.parse(fs.readFileSync(PROJECTS_CONFIG, 'utf8'));

    // æŸ¥æ‰¾é¡¹ç›®ï¼ˆå¯èƒ½åœ¨ projects æˆ– external ä¸­ï¼‰
    let project = config.projects[name];
    if (!project && config.external && config.external[name]) {
      project = config.external[name];
    }

    if (!project) {
      return res.status(404).json({ error: 'é¡¹ç›®ä¸å­˜åœ¨' });
    }

    // å¦‚æœæ˜¯ç»å¯¹è·¯å¾„ç›´æ¥ä½¿ç”¨ï¼Œå¦åˆ™ç›¸å¯¹äºé¡¹ç›®æ ¹ç›®å½•
    const projectPath = path.isAbsolute(project.path)
      ? project.path
      : path.join(PROJECT_ROOT, project.path);
    const result = await executeAction(action, projectPath, project, params);

    res.json(result);
  } catch (error) {
    res.status(500).json({ error: 'æ‰§è¡Œæ“ä½œå¤±è´¥', message: error.message });
  }
});

// ========== è¾…åŠ©å‡½æ•° ==========

// æ£€æŸ¥é¡¹ç›®çŠ¶æ€
async function checkProjectStatus(projectPath, project) {
  const status = {
    exists: fs.existsSync(projectPath),
    hasGit: false,
    gitBranch: null,
    uncommittedFiles: 0,
    hasDependencies: false,
    dependenciesInstalled: false,
    port: project.port || null
  };

  if (!status.exists) return status;

  // æ£€æŸ¥ Git çŠ¶æ€
  const gitPath = path.join(projectPath, '.git');
  status.hasGit = fs.existsSync(gitPath);

  if (status.hasGit) {
    try {
      const { stdout: branch } = await execPromise('git branch --show-current', { cwd: projectPath });
      status.gitBranch = branch.trim();

      const { stdout: statusOutput } = await execPromise('git status --porcelain', { cwd: projectPath });
      status.uncommittedFiles = statusOutput.trim().split('\n').filter(l => l).length;
    } catch (error) {
      // Git å‘½ä»¤å¤±è´¥ï¼Œå¿½ç•¥
    }
  }

  // æ£€æŸ¥ä¾èµ–çŠ¶æ€
  const hasPackageJson = fs.existsSync(path.join(projectPath, 'package.json'));
  const hasRequirements = fs.existsSync(path.join(projectPath, 'requirements.txt')) ||
                          fs.existsSync(path.join(projectPath, 'backend/requirements.txt'));

  status.hasDependencies = hasPackageJson || hasRequirements;

  if (hasPackageJson) {
    status.dependenciesInstalled = fs.existsSync(path.join(projectPath, 'node_modules'));
  } else if (hasRequirements) {
    status.dependenciesInstalled = fs.existsSync(path.join(projectPath, 'venv')) ||
                                   fs.existsSync(path.join(projectPath, '.venv')) ||
                                   fs.existsSync(path.join(projectPath, 'backend/venv'));
  }

  return status;
}

// æ‰§è¡Œæ“ä½œ
async function executeAction(action, projectPath, project, params) {
  switch (action) {
    case 'open-directory':
      await execPromise(`open "${projectPath}"`);
      return { success: true, message: 'å·²æ‰“å¼€é¡¹ç›®ç›®å½•' };

    case 'open-vscode':
      await execPromise(`code "${projectPath}"`);
      return { success: true, message: 'å·²åœ¨ VSCode ä¸­æ‰“å¼€' };

    case 'git-status':
      const { stdout } = await execPromise('git status', { cwd: projectPath });
      return { success: true, output: stdout };

    case 'install-deps':
      if (fs.existsSync(path.join(projectPath, 'package.json'))) {
        await execPromise('npm install', { cwd: projectPath });
        return { success: true, message: 'npm ä¾èµ–å®‰è£…å®Œæˆ' };
      } else if (fs.existsSync(path.join(projectPath, 'requirements.txt'))) {
        await execPromise('pip install -r requirements.txt', { cwd: projectPath });
        return { success: true, message: 'Python ä¾èµ–å®‰è£…å®Œæˆ' };
      }
      return { success: false, message: 'æœªæ‰¾åˆ°ä¾èµ–é…ç½®æ–‡ä»¶' };

    default:
      return { success: false, message: 'æœªçŸ¥æ“ä½œ' };
  }
}

// ========== é¡¹ç›® CRUD API ==========

// æ·»åŠ æ–°é¡¹ç›®
app.post('/api/projects/:name', async (req, res) => {
  try {
    const { name } = req.params;
    const { project, isExternal } = req.body;

    const config = JSON.parse(fs.readFileSync(PROJECTS_CONFIG, 'utf8'));

    // æ£€æŸ¥é¡¹ç›®æ˜¯å¦å·²å­˜åœ¨
    if (config.projects[name] || (config.external && config.external[name])) {
      return res.status(400).json({ error: 'é¡¹ç›®åç§°å·²å­˜åœ¨' });
    }

    // æ·»åŠ åˆ°ç›¸åº”çš„åˆ†ç±»
    if (isExternal) {
      if (!config.external) config.external = {};
      config.external[name] = project;
    } else {
      config.projects[name] = project;
    }

    // æ›´æ–° active/archived æ•°ç»„
    if (project.status === 'active') {
      if (!config.active) config.active = [];
      if (!config.active.includes(name)) {
        config.active.push(name);
      }
    } else if (project.status === 'archived') {
      if (!config.archived) config.archived = [];
      if (!config.archived.includes(name)) {
        config.archived.push(name);
      }
    }

    // æ›´æ–°å…ƒæ•°æ®
    if (config.meta) {
      config.meta.totalProjects = (config.meta.totalProjects || 0) + 1;
      if (project.status === 'active') {
        config.meta.activeProjects = (config.meta.activeProjects || 0) + 1;
      }
    }

    fs.writeFileSync(PROJECTS_CONFIG, JSON.stringify(config, null, 2), 'utf8');

    // åŒæ­¥åˆ°æ•°æ®åº“
    db.syncProjectsFromConfig(config);

    // è‡ªåŠ¨è§¦å‘é¡¹ç›®åˆ†æï¼ˆå¼‚æ­¥ï¼‰
    const projectPath = isExternal ? project.path : path.join(PROJECT_ROOT, project.path);
    if (fs.existsSync(projectPath)) {
      setImmediate(async () => {
        try {
          console.log(`[ProjectCRUD] è‡ªåŠ¨åˆ†ææ–°é¡¹ç›®: ${name}`);
          db.updateProjectAnalysisStatus(name, 'analyzing');
          const projectAnalyzer = require('./projectAnalyzer');
          const analysis = await projectAnalyzer.analyzeProject(name, projectPath);
          db.saveProjectAnalysis(name, analysis);
          console.log(`[ProjectCRUD] âœ… é¡¹ç›®åˆ†æå®Œæˆ: ${name}`);
        } catch (error) {
          console.error(`[ProjectCRUD] âŒ é¡¹ç›®åˆ†æå¤±è´¥: ${name}`, error);
          db.updateProjectAnalysisStatus(name, 'failed', error.message);
        }
      });
    }

    res.json({ success: true, message: 'é¡¹ç›®æ·»åŠ æˆåŠŸ' });
  } catch (error) {
    res.status(500).json({ error: 'æ·»åŠ é¡¹ç›®å¤±è´¥', message: error.message });
  }
});

// æ›´æ–°é¡¹ç›®
app.put('/api/projects/:name', async (req, res) => {
  try {
    const { name } = req.params;
    const { project, isExternal } = req.body;

    const config = JSON.parse(fs.readFileSync(PROJECTS_CONFIG, 'utf8'));

    // æŸ¥æ‰¾é¡¹ç›®
    let oldProject = config.projects[name];
    let wasExternal = false;
    if (!oldProject && config.external && config.external[name]) {
      oldProject = config.external[name];
      wasExternal = true;
    }

    if (!oldProject) {
      return res.status(404).json({ error: 'é¡¹ç›®ä¸å­˜åœ¨' });
    }

    // åˆ é™¤æ—§ä½ç½®
    if (wasExternal) {
      delete config.external[name];
    } else {
      delete config.projects[name];
    }

    // æ·»åŠ åˆ°æ–°ä½ç½®
    if (isExternal) {
      if (!config.external) config.external = {};
      config.external[name] = project;
    } else {
      config.projects[name] = project;
    }

    // æ›´æ–° active/archived æ•°ç»„
    if (config.active) {
      config.active = config.active.filter(n => n !== name);
    }
    if (config.archived) {
      config.archived = config.archived.filter(n => n !== name);
    }

    if (project.status === 'active') {
      if (!config.active) config.active = [];
      config.active.push(name);
    } else if (project.status === 'archived') {
      if (!config.archived) config.archived = [];
      config.archived.push(name);
    }

    fs.writeFileSync(PROJECTS_CONFIG, JSON.stringify(config, null, 2), 'utf8');

    // åŒæ­¥åˆ°æ•°æ®åº“
    db.syncProjectsFromConfig(config);

    res.json({ success: true, message: 'é¡¹ç›®æ›´æ–°æˆåŠŸ' });
  } catch (error) {
    res.status(500).json({ error: 'æ›´æ–°é¡¹ç›®å¤±è´¥', message: error.message });
  }
});

// åˆ é™¤é¡¹ç›®
app.delete('/api/projects/:name', (req, res) => {
  try {
    const { name } = req.params;

    const config = JSON.parse(fs.readFileSync(PROJECTS_CONFIG, 'utf8'));

    // æŸ¥æ‰¾é¡¹ç›®
    let found = false;
    if (config.projects[name]) {
      delete config.projects[name];
      found = true;
    } else if (config.external && config.external[name]) {
      delete config.external[name];
      found = true;
    }

    if (!found) {
      return res.status(404).json({ error: 'é¡¹ç›®ä¸å­˜åœ¨' });
    }

    // ä» active/archived æ•°ç»„ä¸­ç§»é™¤
    if (config.active) {
      config.active = config.active.filter(n => n !== name);
    }
    if (config.archived) {
      config.archived = config.archived.filter(n => n !== name);
    }

    // æ›´æ–°å…ƒæ•°æ®
    if (config.meta) {
      config.meta.totalProjects = Math.max(0, (config.meta.totalProjects || 0) - 1);
      if (config.active) {
        config.meta.activeProjects = config.active.length;
      }
    }

    fs.writeFileSync(PROJECTS_CONFIG, JSON.stringify(config, null, 2), 'utf8');

    // åŒæ­¥åˆ°æ•°æ®åº“
    db.syncProjectsFromConfig(config);

    res.json({ success: true, message: 'é¡¹ç›®åˆ é™¤æˆåŠŸ' });
  } catch (error) {
    res.status(500).json({ error: 'åˆ é™¤é¡¹ç›®å¤±è´¥', message: error.message });
  }
});

// æ‰“å¼€æ–‡ä»¶å¤¹é€‰æ‹©å¯¹è¯æ¡†å¹¶è‡ªåŠ¨è¯†åˆ«é¡¹ç›®ä¿¡æ¯
app.post('/api/select-folder', async (req, res) => {
  try {
    // ä½¿ç”¨ osascript (macOS) æˆ–å…¶ä»–ç³»ç»Ÿå‘½ä»¤æ‰“å¼€æ–‡ä»¶å¤¹é€‰æ‹©å™¨
    const platform = process.platform;
    let folderPath = '';

    if (platform === 'darwin') {
      // macOS - ä½¿ç”¨ AppleScript
      const { stdout } = await execPromise(
        'osascript -e \'POSIX path of (choose folder with prompt "é€‰æ‹©é¡¹ç›®æ–‡ä»¶å¤¹")\''
      );
      folderPath = stdout.trim();
    } else if (platform === 'win32') {
      // Windows - ä½¿ç”¨ PowerShell
      const psScript = `
        Add-Type -AssemblyName System.Windows.Forms
        $dialog = New-Object System.Windows.Forms.FolderBrowserDialog
        $dialog.Description = "é€‰æ‹©é¡¹ç›®æ–‡ä»¶å¤¹"
        $result = $dialog.ShowDialog()
        if ($result -eq 'OK') { Write-Output $dialog.SelectedPath }
      `;
      const { stdout } = await execPromise(`powershell -Command "${psScript}"`);
      folderPath = stdout.trim();
    } else {
      // Linux - å°è¯•ä½¿ç”¨ zenity
      const { stdout } = await execPromise('zenity --file-selection --directory --title="é€‰æ‹©é¡¹ç›®æ–‡ä»¶å¤¹"');
      folderPath = stdout.trim();
    }

    if (!folderPath) {
      return res.json({ success: false, message: 'æœªé€‰æ‹©æ–‡ä»¶å¤¹' });
    }

    // è‡ªåŠ¨è¯†åˆ«é¡¹ç›®ä¿¡æ¯
    const projectInfo = await detectProjectInfo(folderPath);

    res.json({
      success: true,
      path: folderPath,
      detected: projectInfo
    });
  } catch (error) {
    res.status(500).json({ error: 'é€‰æ‹©æ–‡ä»¶å¤¹å¤±è´¥', message: error.message });
  }
});

// è‡ªåŠ¨æ£€æµ‹é¡¹ç›®ä¿¡æ¯
async function detectProjectInfo(projectPath) {
  const info = {
    name: path.basename(projectPath),
    type: '',
    stack: [],
    description: '',
    port: null
  };

  try {
    // æ£€æµ‹é¡¹ç›®ç±»å‹å’ŒæŠ€æœ¯æ ˆ
    info.stack = await identifyTechStack(projectPath);

    // è¯»å– README ç”Ÿæˆæè¿°
    const readmeFiles = ['README.md', 'readme.md', 'README', 'README.txt'];
    for (const readme of readmeFiles) {
      const readmePath = path.join(projectPath, readme);
      if (fs.existsSync(readmePath)) {
        const content = fs.readFileSync(readmePath, 'utf8');
        // æå–ç¬¬ä¸€æ®µä½œä¸ºæè¿°
        const lines = content.split('\n').filter(line => line.trim());
        info.description = lines.slice(0, 3).join(' ').substring(0, 200);
        break;
      }
    }

    // å°è¯•æ£€æµ‹ç«¯å£
    const packageJsonPath = path.join(projectPath, 'package.json');
    if (fs.existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      // ä» scripts ä¸­æŸ¥æ‰¾ç«¯å£ä¿¡æ¯
      const scripts = Object.values(packageJson.scripts || {}).join(' ');
      const portMatch = scripts.match(/PORT[=:\s]+(\d+)|port[=:\s]+(\d+)|--port[=\s]+(\d+)/i);
      if (portMatch) {
        info.port = parseInt(portMatch[1] || portMatch[2] || portMatch[3]);
      }
    }

  } catch (error) {
    console.error('æ£€æµ‹é¡¹ç›®ä¿¡æ¯å¤±è´¥:', error);
  }

  return info;
}

// è¯†åˆ«æŠ€æœ¯æ ˆ
async function identifyTechStack(projectPath) {
  const stack = new Set();

  // æ£€æŸ¥æ–‡ä»¶å­˜åœ¨æ€§
  const files = {
    'package.json': false,
    'requirements.txt': false,
    'Cargo.toml': false,
    'go.mod': false,
    'pom.xml': false,
    'build.gradle': false,
    'Gemfile': false,
    'composer.json': false
  };

  for (const file of Object.keys(files)) {
    files[file] = fs.existsSync(path.join(projectPath, file));
  }

  // Node.js / JavaScript / TypeScript
  if (files['package.json']) {
    try {
      const packageJson = JSON.parse(
        fs.readFileSync(path.join(projectPath, 'package.json'), 'utf8')
      );
      const deps = { ...packageJson.dependencies, ...packageJson.devDependencies };

      // æ¡†æ¶æ£€æµ‹
      if (deps.react || deps['@types/react']) stack.add('React');
      if (deps.vue || deps['@vue/cli-service']) stack.add('Vue');
      if (deps['@angular/core']) stack.add('Angular');
      if (deps.next) stack.add('Next.js');
      if (deps.nuxt) stack.add('Nuxt.js');
      if (deps.svelte) stack.add('Svelte');

      // åç«¯æ¡†æ¶
      if (deps.express) stack.add('Express');
      if (deps.koa) stack.add('Koa');
      if (deps['@nestjs/core']) stack.add('NestJS');
      if (deps.fastify) stack.add('Fastify');

      // æ„å»ºå·¥å…·
      if (deps.vite) stack.add('Vite');
      if (deps.webpack) stack.add('Webpack');

      // å…¶ä»–
      if (deps.typescript || deps['@types/node']) stack.add('TypeScript');
      if (deps.electron) stack.add('Electron');
      if (deps['@tauri-apps/api']) stack.add('Tauri');

      // å¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°ç‰¹å®šæ¡†æ¶ï¼Œæ ‡è®°ä¸º Node.js
      if (stack.size === 0 || (stack.size === 1 && stack.has('TypeScript'))) {
        stack.add('Node.js');
      }
    } catch (error) {
      stack.add('Node.js');
    }
  }

  // Python
  if (files['requirements.txt']) {
    try {
      const requirements = fs.readFileSync(
        path.join(projectPath, 'requirements.txt'),
        'utf8'
      );

      if (requirements.includes('django')) stack.add('Django');
      if (requirements.includes('flask')) stack.add('Flask');
      if (requirements.includes('fastapi')) stack.add('FastAPI');
      if (requirements.includes('tornado')) stack.add('Tornado');

      if (stack.size === 0) {
        stack.add('Python');
      }
    } catch (error) {
      stack.add('Python');
    }
  }

  // Rust
  if (files['Cargo.toml']) {
    stack.add('Rust');
  }

  // Go
  if (files['go.mod']) {
    stack.add('Go');
  }

  // Java
  if (files['pom.xml']) {
    stack.add('Java');
    stack.add('Maven');
  }
  if (files['build.gradle']) {
    stack.add('Java');
    stack.add('Gradle');
  }

  // Ruby
  if (files['Gemfile']) {
    stack.add('Ruby');
    try {
      const gemfile = fs.readFileSync(path.join(projectPath, 'Gemfile'), 'utf8');
      if (gemfile.includes('rails')) stack.add('Rails');
    } catch (error) {
      // å¿½ç•¥é”™è¯¯
    }
  }

  // PHP
  if (files['composer.json']) {
    stack.add('PHP');
    try {
      const composer = JSON.parse(
        fs.readFileSync(path.join(projectPath, 'composer.json'), 'utf8')
      );
      if (composer.require && composer.require['laravel/framework']) {
        stack.add('Laravel');
      }
    } catch (error) {
      // å¿½ç•¥é”™è¯¯
    }
  }

  return Array.from(stack);
}

// æ³¨å†Œè¿›ç¨‹ç®¡ç†è·¯ç”±
registerProcessRoutes(app, PROJECT_ROOT, PROJECTS_CONFIG, fs);

// æ³¨å†Œé¡¹ç›®ç®¡ç†è·¯ç”±ï¼ˆTodos, Milestones, Labels ç­‰ï¼‰
registerManagementRoutes(app);

// æ³¨å†Œé¡¹ç›®åˆ†æè·¯ç”±
registerAnalysisRoutes(app, PROJECT_ROOT, PROJECTS_CONFIG);

// å¯åŠ¨æœåŠ¡å™¨
app.listen(PORT, () => {
  console.log(`ğŸš€ é¡¹ç›®ç®¡ç†ç³»ç»Ÿåç«¯è¿è¡Œåœ¨ http://localhost:${PORT}`);
  console.log(`ğŸ“ é¡¹ç›®æ ¹ç›®å½•: ${PROJECT_ROOT}`);
  console.log(`ğŸ“‹ é…ç½®æ–‡ä»¶: ${PROJECTS_CONFIG}`);
  console.log(`ğŸ’¾ æ•°æ®åº“: project-manager.db`);

  // åŒæ­¥é¡¹ç›®é…ç½®åˆ°æ•°æ®åº“
  try {
    const config = JSON.parse(fs.readFileSync(PROJECTS_CONFIG, 'utf8'));
    db.syncProjectsFromConfig(config);
    console.log('âœ… é¡¹ç›®é…ç½®å·²åŒæ­¥åˆ°æ•°æ®åº“');
  } catch (error) {
    console.warn('âš ï¸  åŒæ­¥é¡¹ç›®é…ç½®å¤±è´¥:', error.message);
  }
});

// ä¼˜é›…å…³é—­
process.on('SIGTERM', () => {
  console.log('æ”¶åˆ° SIGTERM ä¿¡å·ï¼Œæ­£åœ¨åœæ­¢æ‰€æœ‰è¿›ç¨‹...');
  processManager.stopAll();
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('\næ”¶åˆ° SIGINT ä¿¡å·ï¼Œæ­£åœ¨åœæ­¢æ‰€æœ‰è¿›ç¨‹...');
  processManager.stopAll();
  process.exit(0);
});
